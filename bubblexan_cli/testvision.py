#!/usr/bin/env python3
"""Visual overlay helper for inspecting OMR detection.

Given a scanned bubble-sheet image and the matching layout JSON generated by
`generate_bubblesheet.py`, this script replicates the scanner's geometry
calculation and emits an annotated image illustrating where the code believes
each bubble lives plus its measured fill score.
"""

from __future__ import annotations

import argparse
from pathlib import Path
from typing import Iterable, Tuple

import cv2
import numpy as np

from scan_bubblesheet import (  # type: ignore[import-not-found]
    LayoutGuide,
    build_layout_to_image_transform,
    load_layout,
    measure_bubble_fill,
    transform_points,
    estimate_pixel_radius,
)


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Create an annotated visualization of bubble detections.",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )
    parser.add_argument("--image", required=True, help="Path to the scanned PNG/JPG to inspect.")
    parser.add_argument("--json", required=True, help="Layout JSON emitted by the generator.")
    parser.add_argument(
        "--output",
        default="annotated.png",
        help="Destination image for the overlay (PNG recommended).",
    )
    parser.add_argument(
        "--threshold",
        type=float,
        default=0.35,
        help="Absolute fill threshold used by the scanner for green highlights.",
    )
    parser.add_argument(
        "--relative-threshold",
        type=float,
        default=0.6,
        help="Relative fallback threshold; visualized as yellow when hit.",
    )
    parser.add_argument(
        "--alpha",
        type=float,
        default=0.6,
        help="Blend ratio for overlay vs original image (0 = only original).",
    )
    parser.add_argument(
        "--show-warnings",
        action="store_true",
        help="Print the same transform warnings the scanner would emit.",
    )
    return parser.parse_args()


def score_to_color(score: float, threshold: float, relative_threshold: float) -> Tuple[int, int, int]:
    if score >= threshold:
        return (0, 200, 0)  # green
    if score >= max(threshold * 0.5, threshold * relative_threshold):
        return (0, 215, 255)  # amber
    return (0, 0, 220)  # red


def annotate_bubbles(
    image: np.ndarray,
    gray: np.ndarray,
    layout: LayoutGuide,
    matrix: np.ndarray,
    threshold: float,
    relative_threshold: float,
) -> np.ndarray:
    overlay = image.copy()

    def draw_group(points: Iterable[Tuple[float, float]], label: str) -> None:
        pts = np.array(points, dtype=np.int32)
        cv2.polylines(overlay, [pts], isClosed=True, color=(255, 255, 0), thickness=1)
        if pts.size:
            cx, cy = pts.mean(axis=0).astype(int)
            cv2.putText(overlay, label, (cx, cy), cv2.FONT_HERSHEY_SIMPLEX, 0.4, (255, 255, 0), 1, cv2.LINE_AA)

    # Draw student ID rows
    for column in layout.student_id_columns:
        for bubble in column.bubbles:
            center = transform_points(matrix, layout.height, [(bubble.x, bubble.y)])[0]
            radius = estimate_pixel_radius(matrix, layout.height, bubble)
            score = measure_bubble_fill(gray, center, radius)
            color = score_to_color(score, threshold, relative_threshold)
            cv2.circle(overlay, tuple(map(int, center)), int(round(radius)), color, 2)
            cv2.putText(
                overlay,
                f"{bubble.label}:{score:.2f}",
                (int(center[0] + radius + 2), int(center[1] - radius)),
                cv2.FONT_HERSHEY_SIMPLEX,
                0.35,
                color,
                1,
                cv2.LINE_AA,
            )

    # Draw question bubbles
    for question in layout.questions:
        for bubble in question.bubbles:
            center = transform_points(matrix, layout.height, [(bubble.x, bubble.y)])[0]
            radius = estimate_pixel_radius(matrix, layout.height, bubble)
            score = measure_bubble_fill(gray, center, radius)
            color = score_to_color(score, threshold, relative_threshold)
            cv2.circle(overlay, tuple(map(int, center)), int(round(radius)), color, 1)
            cv2.putText(
                overlay,
                f"Q{question.number}{bubble.label}:{score:.2f}",
                (int(center[0] + radius + 2), int(center[1])),
                cv2.FONT_HERSHEY_SIMPLEX,
                0.3,
                color,
                1,
                cv2.LINE_AA,
            )

    # Outline alignment markers
    if layout.alignment_markers:
        corners = []
        for marker in layout.alignment_markers[:4]:
            size = marker.get("size", 0.0)
            pts = [
                (marker["x"], marker["y"]),
                (marker["x"] + size, marker["y"]),
                (marker["x"] + size, marker["y"] + size),
                (marker["x"], marker["y"] + size),
            ]
            transformed = transform_points(matrix, layout.height, pts)
            draw_group(transformed, "marker")
            corners.extend(transformed)
        if corners:
            draw_group(corners, "alignment hull")

    return overlay


def main() -> None:
    args = parse_args()
    image_path = Path(args.image)
    if not image_path.exists():
        raise FileNotFoundError(image_path)
    gray = cv2.imread(str(image_path), cv2.IMREAD_GRAYSCALE)
    if gray is None:
        raise RuntimeError(f"Unable to read {image_path}")
    color = cv2.cvtColor(gray, cv2.COLOR_GRAY2BGR)

    layout = load_layout(Path(args.json))
    matrix, warnings = build_layout_to_image_transform(layout, gray)
    if args.show_warnings:
        for warning in warnings:
            print(f"WARNING: {warning}")

    overlay = annotate_bubbles(color, gray, layout, matrix, args.threshold, args.relative_threshold)
    blended = cv2.addWeighted(overlay, args.alpha, color, 1 - args.alpha, 0)
    output_path = Path(args.output)
    output_path.parent.mkdir(parents=True, exist_ok=True)
    if not cv2.imwrite(str(output_path), blended):
        raise RuntimeError(f"Failed to write {output_path}")
    print(f"Wrote visualization to {output_path}")


if __name__ == "__main__":
    main()
